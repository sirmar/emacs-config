#+TITLE: Emacs configuration using Org mode
#+OPTIONS: toc:2 tags:nil todo:nil

* Introduction
Two things happened at the same time. I learned about the existence
of org mode and I found new inspiration to play around with my Emacs
configuration. I figured, why not combine the two as a way to learn
org mode and to find out what is out there in terms of helpful tools
to use in my setup. This is the result.

Feel free to steal anything you find useful.

--- Marcus Veib√§ck ([[mailto:sirmar@gmail.com][sirmar@gmail.com]])

* Dependencies
This configuration have some external dependencies that need to be installed in order
for everything to work. So far, I have only tried it on OS X.

** Mac
*** Homebrew
Homepage: [[http://brew.sh]]

Download and install Homebrew.
Instructions can be found on the website above.

*** Aspell
Homepage: [[http://aspell.net]]

Install the spell checker Aspell using brew.

#+BEGIN_SRC sh
  brew install aspell --with-lang-en
#+END_SRC

*** Virtualenv
Homepage: [[http://docs.python-guide.org/en/latest/dev/virtualenvs/]]

Install python virtual environment using pip:

#+BEGIN_SRC sh
pip install virtualenv
#+END_SRC

*** Pylint
Homepage: [[http://www.pylint.org]]

Install pylint using pip:

#+BEGIN_SRC sh
pip install pylint
#+END_SRC

* Emacs configuration
** Starting Emacs                                                  :startup:
*** Cleaning the interface
The Emacs window should be as clean as possible. Therefor the
menu bar, the tool bar and the scroll bar are removed.

Also I want the buffers to be clean, so start up message and
scratch buffer message are both removed.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (setq inhibit-startup-message t)
  (setq initial-scratch-message "")
#+END_SRC

*** The emacs frame
I prefer my Emacs to use most of the screen. Here the position and
size of the program window are set.

#+BEGIN_SRC emacs-lisp
  (when window-system (set-frame-size (selected-frame) 195 47))
  (when window-system (set-frame-position (selected-frame) 20 40))
#+END_SRC

** Packages                                                       :packages:
*** Package system
The built in package system needs to be initialized and the
package archive for melpa is added.

#+BEGIN_SRC emacs-lisp
  (setq package-enable-at-startup nil)
  (package-initialize)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
#+END_SRC

*** Use package
Homepage: [[https://github.com/jwiegley/use-package]]

I use "Use package" to ensure that all my packages are downloaded and
installed if missing at start up. Also, it offers a neat way to define
keys and initialize packages.

Here "Use package" is installed the first time Emacs is started
on a new computer.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
#+END_SRC

*** Auto compile
Homepage: [[https://github.com/tarsius/auto-compile]]

This package makes sure that byte compiled files are recompiled when
the source has changed.

#+BEGIN_SRC emacs-lisp
  (use-package dash
    :ensure t)

  (use-package auto-compile
    :ensure t
    :init
    (progn
      (auto-compile-on-load-mode)
      (setq load-prefer-newer t)))
#+END_SRC

** Text manipulation                                                  :edit:
*** Indentation
Setting lisp indentation to two spaces.

#+BEGIN_SRC emacs-lisp
  (setq lisp-indent-offset 2)
#+END_SRC

A small utility function that indents the whole buffer.

#+BEGIN_SRC emacs-lisp
  (defun indent-buffer ()
    "Indents whole buffer."
    (interactive)
    (indent-region (point-min) (point-max) nil))
#+END_SRC

*** Cut, copy and paste
Make sure that active regions are deleted if I start writing. Also
insert at Emacs cursor and not mouse cursor when pasting into buffer
with the mouse.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode)
  (setq mouse-yank-at-point t)
#+END_SRC

Make C-w context aware and remove the whole current line if
no region is active. Otherwise let it work just as before.

#+BEGIN_SRC emacs-lisp
  (defun kill-line-or-region ()
    "Cut region. If no region cut current symbol."
    (interactive)
    (if (use-region-p) (kill-region (region-beginning) (region-end))
      (kill-whole-line)))

  (bind-key "C-w" 'kill-line-or-region)
#+END_SRC

Bind M-C-backspace to remove a while balanced expression, i.e from
the current ending parenthesis back to the starting.

#+BEGIN_SRC emacs-lisp
  (bind-key "M-C-<backspace>" 'sp-backward-kill-sexp)
#+END_SRC

*** Change inner                                                  :package:
Homepage: [[https://github.com/emacsmirror/change-inner]]

While inside a pair like parentheses, quotation marks and the like,
inner will remove every thing between the pair, while outer will
remove everything including the pair itself.

#+BEGIN_SRC emacs-lisp
  (use-package change-inner
    :ensure t
    :bind ( ("M-i" . change-inner)
            ("M-o" . change-outer)))
#+END_SRC

*** Expand region                                                 :package:
Homepage: [[https://github.com/emacsmirror/change-inner]]

Marks in a syntax aware manner, starting with the current word.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ( ("C-S-SPC" . er/expand-region)))
#+END_SRC

*** New lines
It can be handy to be able to create new lines above and below
the current one, regardless of cursor position.

#+BEGIN_SRC emacs-lisp
  (defun open-line-below ()
    "Create new line below the current one."
    (interactive)
    (end-of-line)
    (newline)
    (indent-for-tab-command))

  (defun open-line-above ()
    "Create new line above the current one."
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (indent-for-tab-command))

  (bind-key "<C-return>" 'open-line-above)
  (bind-key "<S-return>" 'open-line-below)
#+END_SRC

This binding join the current line with the next line regardless
of the current cursor position.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-j" (lambda () (interactive) (join-line -1)))
#+END_SRC

*** Move text                                                     :package:
Homepage: [[http://emacswiki.org/emacs/MoveText]]

Makes it possible to move a whole region of text up and down past
existing lines. The region will be indented as well.

#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :ensure t
    :bind ( ("<M-up>"   . move-text-up)
            ("<M-down>" . move-text-down)))
#+END_SRC

*** Other
Comment a region. If no region is active, comment the current line.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c C-c" 'comment-region)
#+END_SRC

This will first remove all spaces but one between two words. Next it
will remove that one as well and lastly it will restore the original
spacing.

#+BEGIN_SRC emacs-lisp
  (bind-key "M-S-SPC" 'cycle-spacing)
#+END_SRC

Why not bind delete to delete.

#+BEGIN_SRC emacs-lisp
  (bind-key "<delete>" 'delete-char)
#+END_SRC

** Navigation                                                          :nav:
*** Smartparen
Homepage: [[https://github.com/Fuco1/smartparens]]

Use to navigate over and into pairs like parentheses. Also I set
it to automatically create the pair sibling. Lastly quotes inside
quotes will be escaped.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :diminish smartparens-mode
    :init
    (progn
      (smartparens-global-mode 1)
      (show-smartparens-global-mode t)
      (setq sp-autoescape-string-quote t))
    :bind
    ( ("<C-M-up>"    . sp-previous-sexp)
      ("<C-M-down>"  . sp-next-sexp)
      ("<C-M-left>"  . sp-backward-up-sexp)
      ("<C-M-right>" . sp-down-sexp)))
#+END_SRC

*** Ace jump mode
Homepage: [[https://github.com/winterTTr/ace-jump-mode]]

This mode will let you jump to any word starting with the
given head character. It even works between visible buffers.

#+BEGIN_SRC emacs-lisp
  (use-package ace-jump-mode
    :ensure t
    :bind ( ("C-f" . ace-jump-word-mode)))
#+END_SRC

*** Tags
#+BEGIN_SRC emacs-lisp
  (setq tags-file-name "~/TAGS")
#+END_SRC

*** Other
This function will let me go back to the last edited place in the buffer.

 #+BEGIN_SRC emacs-lisp
   (defun goto-last-edit-point ()
    "Sets the cursor on the last edit point."
    (interactive)
    (let ((undos buffer-undo-list))
      (if (listp undos)
          (while (and undos
                      (let ((pos (or (cdr-safe (car undos)) (car undos))))
                        (not (and (integerp pos) (goto-char (abs pos))))))
            (setq undos (cdr undos))))))

   (bind-key "C-c SPC" 'goto-last-edit-point)
 #+END_SRC

Make beginning of line context aware. It will now go back to the
first non white space character on the current line. If pressed again
it will go to the beginning of line and then to the beginning of the buffer.

#+BEGIN_SRC emacs-lisp
  (defun my-home ()
    "Move to indentation, beginning of line and beginning of buffer."
    (interactive)
    (if (bolp) (beginning-of-buffer)
      (skip-chars-backward " \t")
      (unless (bolp) (back-to-indentation))))

  (bind-key "C-a" 'my-home)
#+END_SRC

Make end of line context aware. It will still go to the end of the line, but if
pressed again the cursor will move to the very end of the buffer.

#+BEGIN_SRC emacs-lisp
  (defun my-end ()
    "Move to end of line and end of buffer."
    (interactive)
    (if (eolp) (end-of-buffer)
      (end-of-line)))

  (bind-key "C-e" 'my-end)
#+END_SRC

Up and down should move logical lines.

#+BEGIN_SRC emacs-lisp
  (bind-key "<down>" 'next-logical-line)
  (bind-key "<up>" 'previous-logical-line)
#+END_SRC

Go to a specific line in current buffer.

#+BEGIN_SRC emacs-lisp
  (bind-key "M-g" 'goto-line)
#+END_SRC

** Search and replace                                               :search:
*** Casing
Searches should ignore case. When replacing casing should be
preserved.

#+BEGIN_SRC emacs-lisp
  (setq case-fold-search t)
  (setq case-replace t)
#+END_SRC

*** Isearch
Regexp search should be the normal for isearch.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-s" 'isearch-forward-regexp)
  (bind-key "C-r" 'isearch-backward-regexp)
#+END_SRC

*** Grep
Do not show the grep command in the grep buffer as it takes
so much buffer space.

#+BEGIN_SRC emacs-lisp
  (defun delete-grep-header ()
    "Hide grep command in grep buffer."
    (save-excursion
      (with-current-buffer grep-last-buffer
        (goto-line 4)
        (end-of-line)
        (narrow-to-region (point) (point-max)))))

  (defadvice grep (after delete-grep-header activate) (delete-grep-header))
  (defadvice rgrep (after delete-grep-header activate) (delete-grep-header))
#+END_SRC

Global ignore list for grep.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "grep"
    '(progn
       (add-to-list 'grep-find-ignored-directories ".*")
       (add-to-list 'grep-find-ignored-files ".*")
       ))
#+END_SRC

Change this template to make grep run in a different way. I used this to get
rid of an error on Windows where to many processes were spawned by xargs.

#+BEGIN_SRC emacs-lisp
  ;; (setq grep-find-template
  ;;   "find . <X> -type f <F> -print0 | xargs -n 100 -0 -e grep <C> -nH -E <R>")
#+END_SRC

When using next and previous error to brows grep hits, recenter the hit in
the buffer. Lastly, bind grep to something.

#+BEGIN_SRC emacs-lisp
  (add-hook 'next-error-hook 'recenter)
  (bind-key "C-c g" 'rgrep)
#+END_SRC

*** Smartscan
Homepage: [[https://github.com/mickeynp/smart-scan]]

Use to search for the next or previous occurrence of the symbol below
the cursor.

#+BEGIN_SRC emacs-lisp
  (use-package smartscan
    :ensure t
    :init
    (progn
      (smartscan-mode 1)
      (setq smartscan-symbol-selector "symbol"))
    :bind
    ( ("M-n" . smartscan-symbol-go-forward)
      ("M-p" . smartscan-symbol-go-backward)))
#+END_SRC

** Fuzzy matching                                                    :fuzzy:
*** Flx ido mode
Homepage: [[https://github.com/lewang/flx]]

#+BEGIN_SRC emacs-lisp
  (use-package flx-ido
    :ensure t
    :init
    (progn
      (ido-mode 1)
      (ido-everywhere 1)
      (flx-ido-mode 1)
      (setq ido-enable-flex-matching t)
      (setq ido-use-faces nil)))
#+END_SRC

*** Ido verticle mode
Homepage: [[https://github.com/gempesaw/ido-vertical-mode.el]]

#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :init
    (progn
      (ido-vertical-mode)))
#+END_SRC

*** Smex
Homepage: [[https://github.com/nonsequitur/smex]]

#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :init
    (progn
      (smex-initialize))
    :bind
    ( ("M-x" . smex)))
#+END_SRC

** Completion                                                   :completion:
*** YaSnippet
Homepage: [[https://github.com/capitaomorte/yasnippet]]

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :init
    (progn
      (yas-global-mode t)))
#+END_SRC

*** Auto Complete
Homepage: [[https://github.com/auto-complete/auto-complete]]

#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :ensure t
    :diminish auto-complete-mode
    :init
    (progn
      (ac-config-default)
      (setq ac-ignore-case nil)
      (setq ac-autos-tart nil)
      (ac-set-trigger-key "TAB")
      (setq ac-auto-show-menu 0.1)))
#+END_SRC

*** Jedi
Homepage: [[https://github.com/tkf/emacs-jedi]]

#+BEGIN_SRC emacs-lisp
  (use-package jedi
    :ensure t
    :init
    (progn
      (add-hook 'python-mode-hook 'jedi:setup)
      (setq jedi:complete-on-dot t))
    :bind
    ( ("M-." . jedi:goto-definition)
      ("M-," . jedi:goto-definition-pop-marker)))
#+END_SRC

*** Hippie expand
#+BEGIN_SRC emacs-lisp
  (setq dabbrev-case-fold-search nil)
  (setq dabbrev-case-replace nil)

  (bind-key "C-<tab>" 'hippie-expand)
  (define-key minibuffer-local-map (kbd "C-<tab>") 'hippie-expand)
#+END_SRC

** Projects                                                           :proj:
*** Projectile
Homepage: [[https://github.com/bbatsov/projectile]]

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (progn
      (projectile-global-mode)
      (setq projectile-mode-line
        '(:eval (format " P[%s]" (projectile-project-name)))))
    :bind
    ( ("C-x f" . projectile-find-file)
      ("C-x b" . projectile-switch-to-buffer)
      ("C-x s" . projectile-switch-project)
      ("C-x g" . projectile-grep)
      ("C-x q" . projectile-replace)
      ("C-x t" . projectile-toggle-between-implementation-and-test)))
#+END_SRC

** Buffers                                                         :buffers:
*** Full frame
Homepage: [[https://github.com/tomterl/fullframe]]

#+BEGIN_SRC emacs-lisp
  (use-package fullframe
    :ensure t
    :init
    (progn
      (fullframe magit-status magit-mode-quit-window)))
#+END_SRC

*** Standard windows
#+BEGIN_SRC emacs-lisp
  (defun config-buffers ()
    "Create three columns and a bottom grep buffer."
    (interactive)
    (setq w (selected-window))
    (split-window w 176 t)
    (setq w2 (split-window w 50))
    (split-window w 88 t)
    (generate-new-buffer "*grep*")
    (set-window-buffer w2 "*grep*"))

  (bind-key "<f8>" 'config-buffers)
#+END_SRC

*** Ace window
Homepage: [[https://github.com/abo-abo/ace-window]]

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :bind
    ( ("C-." . ace-window)))
#+END_SRC

*** Other settings
#+BEGIN_SRC emacs-lisp
  (line-number-mode t)
  (column-number-mode t)
  (setq frame-title-format "%b")

  (bind-key "C-x C-b" 'switch-to-buffer)
#+END_SRC

** Instant feedback                                               :feedback:
*** White space mode
#+BEGIN_SRC emacs-lisp
  (global-whitespace-mode t)
  (diminish 'global-whitespace-mode)
  (setq whitespace-line-column 100)
  (setq whitespace-style '(face empty tabs trailing lines-tail indentation::space))
  (add-hook 'before-save-hook 'sanitize-whitespace)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun sanitize-whitespace ()
    "Converts all tabs to spaces."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "[ \t]+$" nil t)
        (replace-match "" nil nil))
      (untabify (point-min) (point-max))))
#+END_SRC

*** Flycheck
Homepage: [[https://github.com/flycheck/flycheck]]

This package need back-ends to do the actual analysis. As of now,
I only use this for python and has [[Pylint]] installed.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :diminish flycheck-mode
    :init
    (progn
      (add-hook 'python-mode-hook 'flycheck-mode)))
#+END_SRC

** Files                                                             :files:
*** Current buffer operations
#+BEGIN_SRC emacs-lisp
  (defun delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))

  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))

  (bind-key "C-x C-k" 'delete-current-buffer-file)
  (bind-key "C-x C-r" 'rename-current-buffer-file)
#+END_SRC

** Building                                                       :building:
*** Debugging
*** Compiling
#+BEGIN_SRC emacs-lisp
  (setq compile-command "")

  (bind-key "<f5>" 'compile)
  (bind-key "<f6>" 'recompile)
  (bind-key "<f7>" 'kill-compilation)
  (bind-key "<f9>" 'previous-error)
  (bind-key "<f10>" 'next-error)
#+END_SRC

*** Tests
** Source control                                                      :scm:
*** Magit
Homepage: [[https://github.com/magit/magit]]

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind
    ( ("C-c s" . magit-status)
      ("C-c b" . magit-blame-mode)))
#+END_SRC

*** Ediff
#+BEGIN_SRC emacs-lisp
  (setq ediff-split-window-function (quote split-window-horizontally))
#+END_SRC

** Org                                                                  :org:
Homepage: [[http://orgmode.org]]

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :init
    (progn
      ))
#+END_SRC

*** Code blocks
#+BEGIN_SRC emacs-lisp
  (set-face-background 'org-block-begin-line "#eeeee0")
  (set-face-background 'org-block-background "#fefefa")
  (set-face-background 'org-block-end-line "#eeeee0")

  (setq org-src-fontify-natively t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq org-structure-template-alist
        '(("s" "#+BEGIN_SRC ?\n\n#+END_SRC" "<src lang=\"?\">\n\n</src>")
          ("e" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE" "<example>\n?\n</example>")
          ("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE" "<quote>\n?\n</quote>")
          ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE" "<verse>\n?\n</verse>")
          ("c" "#+BEGIN_COMMENT\n?\n#+END_COMMENT")
          ("p" "#+BEGIN_PRACTICE\n?\n#+END_PRACTICE")
          ("l" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "<src lang=\"emacs-lisp\">\n?\n</src>")
          ("L" "#+LATEX: " "<literal style=\"latex\">?</literal>")
          ("h" "#+BEGIN_HTML\n?\n#+END_HTML" "<literal style=\"html\">\n?\n</literal>")
          ("H" "#+HTML: " "<literal style=\"html\">?</literal>")
          ("a" "#+BEGIN_ASCII\n?\n#+END_ASCII")
          ("A" "#+ASCII: ")
          ("i" "#+INDEX: ?" "#+index: ?")
          ("I" "#+INCLUDE %file ?" "<include file=%file markup=\"?\">")))
#+END_SRC

*** Tasks
#+BEGIN_SRC emacs-lisp
    (setq org-todo-keywords '((sequence "TODO" "DONE")))
    (setq org-log-done "time")
    (setq org-hierarchical-todo-statistics nil)
#+END_SRC

*** Capture
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (setq org-default-notes-file (concat org-directory "/todo.org"))
              (define-key global-map "\C-cc" 'org-capture)
              ))
#+END_SRC

*** Indentation and wrapping
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-startup-truncated nil)
#+END_SRC

** Misc
*** Discover
Homepage: [[https://github.com/mickeynp/discover.el]]

#+BEGIN_SRC emacs-lisp
  (use-package discover
    :ensure t
    :init
    (progn
      (global-discover-mode 1)))
#+END_SRC

*** Spelling
#+BEGIN_SRC emacs-lisp
  (setq ispell-dictionary "english")
  (setq ispell-program-name "aspell")

  (add-hook 'text-mode-hook (lambda () (flyspell-mode 1)))
  (add-hook 'org-mode-hook  (lambda () (flyspell-mode 1)))
  (add-hook 'prog-mode-hook (lambda () (flyspell-prog-mode)))

  (eval-after-load "flyspell"
    '(progn
       (define-key flyspell-mode-map (kbd "C-.") nil)))

  (bind-key "C--" 'flyspell-auto-correct-word)
#+END_SRC

*** Backup
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

*** Yes and no
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Bindings
#+BEGIN_SRC emacs-lisp
  (bind-key "<f12>" 'call-last-kbd-macro)
  (bind-key "C-z" 'undo)
#+END_SRC

* Tasks [14/16]
** To do
*** TODO Write descriptions in configuration sections                   :doc:
*** TODO Create task capture templates                                  :org:
** History
*** DONE Check why src block background does not work             :bug:org:
CLOSED: [2015-01-28 Wed 11:37]
*** DONE Diminish modes with use-package
CLOSED: [2015-01-28 Wed 11:05]
*** DONE Load org with use-package                                    :org:
CLOSED: [2015-01-28 Wed 11:05]

*** DONE Link to packages on the internet                               :doc:
CLOSED: [2015-01-28 Wed 09:43]

*** DONE Write the dependencies section                                 :doc:
CLOSED: [2015-01-27 Tue 22:08]
*** DONE Get spell checking to work                                     :new:
CLOSED: [2015-01-27 Tue 20:18]
*** DONE Replace global key with bind key macro
CLOSED: [2015-01-27 Tue 19:34]
*** DONE Rewrite configuration using use-package                        :new:
CLOSED: [2015-01-27 Tue 19:27]
*** DONE Remove cask                                                   :cask:
CLOSED: [2015-01-27 Tue 19:26]
*** DONE Create Emacs-lisp source block template                        :org:
CLOSED: [2015-01-27 Tue 15:44]
*** DONE Write introduction                                             :doc:
CLOSED: [2015-01-27 Tue 14:50]
*** DONE Redo configuration as an org mode file                         :doc:
CLOSED: [2015-01-27 Tue 14:50]
*** DONE Change C-w to remove line when no region                      :edit:
CLOSED: [2015-01-27 Tue 14:50]
*** DONE Remove M-k binding                                            :edit:
CLOSED: [2015-01-27 Tue 14:50]
